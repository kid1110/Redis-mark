# 简单动态字符串

## 定义
 Redis使用的字符串键值对底层使用的是SDS，代码定义如下：

``` c
  struct sdshdr{
    //记录数组中已经使用的字节数量
    int len;
    //记录SDS保存的字符串长度
    int free;
    //保存字符串
    char buf[];
  };
```
以保存**redis**为例子： len=5; free=0; buf="redis\0"
注：len记录的不含\0的字符长度

## 为什么要封装SDS而不是直接使用C语言的字符串

* **常数复杂度获取字符串长度**
  当我们使用SDS时，可以通过常数复杂度获取字符串的长度（只需要查len字段既可获取）

* **杜绝缓冲区溢出**
  当使用C语言字符串拼接函数时，需认为检查字符串自身长度并且需要分配足够多的内存，一旦内存分配不足，容易修改另一个数据地址的内容，造成缓冲区溢出，而SDS API需要对SDS进行修改时，会检查大小并且自动扩展空间，不会出现缓冲区溢出的问题。
* **减少修改字符串带来的内存重新分配次数**
 在SDS中，buf中可以包含未被使用的字节，这些字节将会记录在free属性中，其中SDS实现了空间预分配和惰性空间释放两种优化策略
* **二进制安全**
C语言字符串必须符合某种编码形式，并且字符串中不能包含空字符，SDS的api是二进制安全的，SDS的api会以处理二进制的方式处理SDS存放到buf数组的数据，buf是用来保存二进制数据的。
* **兼容C字符串函数**
 SDS api遵循C语言字符串以空字符串结尾的管理，可以重用C语言定义的函数，可以减少不必要的代码重复。


 1 **空间预分配**
 对字符串进行增长修改的操作时，SDS会为字符串分配额外的未使用空间，公式如下：
 (1)对SDS修改后，当len < 1MB,那么程序分配和len属性同样大小的未使用空间，此时len = free
 举例：当len变成13字节时，len= free = 13B,buf实际的长度  = 13 + 13 + 1 = 27B
 (2)对SDS修改后，当len > 1MB, 程序会分配1MB的未使用空间，如果修改SDS后，SDS的len = 30 MB 则，free = 1MB
 buf = 30MB + 1MB +1B

 通过空间预分配， Redis可以减少联系执行字符串增长操作所需要的内存分配次数。


 2 **惰性空间释放**
 当对字符串进行删减长度时，SDS并不会直接释放删除的空间，而是修改free字段以此减少字符串所需的内存分配次数。


 

  
